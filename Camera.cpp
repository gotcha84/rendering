#include <math.h>
#include <iostream> // to print to stdout
#include <sstream> // to convert float to string
#include <iomanip> // to round floats
#include <string>
#include <Gl/glut.h>

#include "Camera.h"
static bool read = false;
using namespace std;
Camera::Camera() {
	c.identity();
}

void Camera::inverse() {
	
	// calculate determinant
	double det = c(0,0)*c(1,1)*c(2,2)*c(3,3)+c(0,0)*c(1,2)*c(2,3)*c(3,1)+c(0,0)*c(1,3)*c(2,1)*c(3,2)
		+c(0,1)*c(1,0)*c(2,3)*c(3,2)+c(0,1)*c(1,2)*c(2,0)*c(3,3)+c(0,1)*c(1,3)*c(2,2)*c(3,0)
		+c(0,2)*c(1,0)*c(2,1)*c(3,3)+c(0,2)*c(1,1)*c(2,3)*c(3,0)+c(0,2)*c(1,3)*c(2,0)*c(3,1)
		+c(0,3)*c(1,0)*c(2,2)*c(3,1)+c(0,3)*c(1,1)*c(2,0)*c(3,2)+c(0,3)*c(1,2)*c(2,1)*c(3,0)
		-c(0,0)*c(1,1)*c(2,3)*c(3,2)-c(0,0)*c(1,2)*c(2,1)*c(3,3)-c(0,0)*c(1,3)*c(2,2)*c(3,1)
		-c(0,1)*c(1,0)*c(2,2)*c(3,3)-c(0,1)*c(1,2)*c(2,3)*c(3,0)-c(0,1)*c(1,3)*c(2,0)*c(3,2)
		-c(0,2)*c(1,0)*c(2,3)*c(3,1)-c(0,2)*c(1,1)*c(2,0)*c(3,3)-c(0,2)*c(1,3)*c(2,1)*c(3,0)
		-c(0,3)*c(1,0)*c(2,1)*c(3,2)-c(0,3)*c(1,1)*c(2,2)*c(3,0)-c(0,3)*c(1,2)*c(2,0)*c(3,1);
 
	// find innverse
	double b[4][4];
 
	b[0][0] = c(1,1)*c(2,2)*c(3,3)+c(1,2)*c(2,3)*c(3,1)+c(1,3)*c(2,1)*c(3,2)-c(1,1)*c(2,3)*c(3,2)-c(1,2)*c(2,1)*c(3,3)-c(1,3)*c(2,2)*c(3,1);
	b[0][1] = c(0,1)*c(2,3)*c(3,2)+c(0,2)*c(2,1)*c(3,3)+c(0,3)*c(2,2)*c(3,1)-c(0,1)*c(2,2)*c(3,3)-c(0,2)*c(2,3)*c(3,1)-c(0,3)*c(2,1)*c(3,2);
	b[0][2] = c(0,1)*c(1,2)*c(3,3)+c(0,2)*c(1,3)*c(3,1)+c(0,3)*c(1,1)*c(3,2)-c(0,1)*c(1,3)*c(3,2)-c(0,2)*c(1,1)*c(3,3)-c(0,3)*c(1,2)*c(3,1);
	b[0][3] = c(0,1)*c(1,3)*c(2,2)+c(0,2)*c(1,1)*c(2,3)+c(0,3)*c(1,2)*c(2,1)-c(0,1)*c(1,2)*c(2,3)-c(0,2)*c(1,3)*c(2,1)-c(0,3)*c(1,1)*c(2,2);
	b[1][0] = c(1,0)*c(2,3)*c(3,2)+c(1,2)*c(2,0)*c(3,3)+c(1,3)*c(2,2)*c(3,0)-c(1,0)*c(2,2)*c(3,3)-c(1,2)*c(2,3)*c(3,0)-c(1,3)*c(2,0)*c(3,2);
	b[1][1] = c(0,0)*c(2,2)*c(3,3)+c(0,2)*c(2,3)*c(3,0)+c(0,3)*c(2,0)*c(3,2)-c(0,0)*c(2,3)*c(3,2)-c(0,2)*c(2,0)*c(3,3)-c(0,3)*c(2,2)*c(3,0);
	b[1][2] = c(0,0)*c(1,3)*c(3,2)+c(0,2)*c(1,0)*c(3,3)+c(0,3)*c(1,2)*c(3,0)-c(0,0)*c(1,2)*c(3,3)-c(0,2)*c(1,3)*c(3,0)-c(0,3)*c(1,0)*c(3,2);
	b[1][3] = c(0,0)*c(1,2)*c(2,3)+c(0,2)*c(1,3)*c(2,0)+c(0,3)*c(1,0)*c(2,2)-c(0,0)*c(1,3)*c(2,2)-c(0,2)*c(1,0)*c(2,3)-c(0,3)*c(1,2)*c(2,0);
	b[2][0] = c(1,0)*c(2,1)*c(3,3)+c(1,1)*c(2,3)*c(3,0)+c(1,3)*c(2,0)*c(3,1)-c(1,0)*c(2,3)*c(3,1)-c(1,1)*c(2,0)*c(3,3)-c(1,3)*c(2,1)*c(3,0);
	b[2][1] = c(0,0)*c(2,3)*c(3,1)+c(0,1)*c(2,0)*c(3,3)+c(0,3)*c(2,1)*c(3,0)-c(0,0)*c(2,1)*c(3,3)-c(0,1)*c(2,3)*c(3,0)-c(0,3)*c(2,0)*c(3,1);
	b[2][2] = c(0,0)*c(1,1)*c(3,3)+c(0,1)*c(1,3)*c(3,0)+c(0,3)*c(1,0)*c(3,1)-c(0,0)*c(1,3)*c(3,1)-c(0,1)*c(1,0)*c(3,3)-c(0,3)*c(1,1)*c(3,0);
	b[2][3] = c(0,0)*c(1,3)*c(2,1)+c(0,1)*c(1,0)*c(2,3)+c(0,3)*c(1,1)*c(2,0)-c(0,0)*c(1,1)*c(2,3)-c(0,1)*c(1,3)*c(2,0)-c(0,3)*c(1,0)*c(2,1);
	b[3][0] = c(1,0)*c(2,2)*c(3,1)+c(1,1)*c(2,0)*c(3,2)+c(1,2)*c(2,1)*c(3,0)-c(1,0)*c(2,1)*c(3,2)-c(1,1)*c(2,2)*c(3,0)-c(1,2)*c(2,0)*c(3,1);
	b[3][1] = c(0,0)*c(2,1)*c(3,2)+c(0,1)*c(2,2)*c(3,0)+c(0,2)*c(2,0)*c(3,1)-c(0,0)*c(2,2)*c(3,1)-c(0,1)*c(2,0)*c(3,2)-c(0,2)*c(2,1)*c(3,0);
	b[3][2] = c(0,0)*c(1,2)*c(3,1)+c(0,1)*c(1,0)*c(3,2)+c(0,2)*c(1,1)*c(3,0)-c(0,0)*c(1,1)*c(3,2)-c(0,1)*c(1,2)*c(3,0)-c(0,2)*c(1,0)*c(3,1);
	b[3][3] = c(0,0)*c(1,1)*c(2,2)+c(0,1)*c(1,2)*c(2,0)+c(0,2)*c(1,0)*c(2,1)-c(0,0)*c(1,2)*c(2,1)-c(0,1)*c(1,0)*c(2,2)-c(0,2)*c(1,1)*c(2,0);
	
	for(int i=0;i<4;i++) {
		for(int j=0;j<4;j++) {
			c.m[i][j] = b[i][j]/det;
		}
	}
 
}

void Camera::set(Vector3 &e, Vector3 &d, Vector3 &up) {


	Vector3 zc = e - d;
	float mag_zc = zc.magnitude();
	zc.divide(mag_zc);

	Vector3 xc;
	xc.cross(up, zc);
	float mag_xc = xc.magnitude();
	xc.divide(mag_xc);
	
	Vector3 yc;
	yc.cross(zc, xc);
	c = Matrix4(xc, yc, zc, e, 0.0, 0.0, 0.0, 1.0);
}

void Camera::identity() {
	c.identity();
}

GLfloat* Camera::getGLMatrix() {
	if (read == false) {
		read = true;
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				//cout << c.get(j, i);
			}

		}
	}
	
	GLfloat retval[16];

	for (int i=0; i<4; i++) {
		for (int j=0; j<4; j++) {
			retval[(i*4)+j] = c.get(j, i);
		}
	}

	//cout << retval[0];
	return retval;
	}